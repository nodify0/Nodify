{
  "id": "filter_sort_node",
  "version": "1.0",
  "name": "Filter & Sort",
  "description": "Filter arrays by conditions, find items, remove duplicates, and sort by fields with custom logic.",
  "group": "Data",
  "category": "data",
  "shape": "2x2",
  "color": "#8B5CF6",
  "icon": "Filter",
  "inputs": [
    {
      "id": "main",
      "label": "Input",
      "position": "left",
      "type": "array",
      "slot": 1
    }
  ],
  "outputs": [
    {
      "id": "main",
      "label": "Output",
      "position": "right",
      "type": "array",
      "slot": 1
    }
  ],
  "properties": [
    {
      "name": "operation",
      "displayName": "Operation",
      "type": "options",
      "default": "filter",
      "required": true,
      "options": [
        {
          "id": "op-filter",
          "label": "Filter",
          "value": "filter"
        },
        {
          "id": "op-find",
          "label": "Find First",
          "value": "find"
        },
        {
          "id": "op-sort",
          "label": "Sort",
          "value": "sort"
        },
        {
          "id": "op-unique",
          "label": "Remove Duplicates",
          "value": "unique"
        },
        {
          "id": "op-limit",
          "label": "Limit/Slice",
          "value": "limit"
        }
      ]
    },
    {
      "name": "inputArray",
      "displayName": "Input Array",
      "type": "string",
      "default": "{{data}}",
      "required": true,
      "description": "Array to process",
      "ui": {
        "component": "code"
      }
    },
    {
      "name": "filterField",
      "displayName": "Field to Filter",
      "type": "string",
      "placeholder": "price, user.age, status",
      "description": "Field path to filter by (supports nested paths)",
      "displayOptions": {
        "show": {
          "operation": [
            "filter",
            "find"
          ]
        }
      }
    },
    {
      "name": "filterOperator",
      "displayName": "Operator",
      "type": "options",
      "default": "equals",
      "options": [
        {
          "id": "op-eq",
          "label": "Equals (==)",
          "value": "equals"
        },
        {
          "id": "op-neq",
          "label": "Not Equals (!=)",
          "value": "notEquals"
        },
        {
          "id": "op-gt",
          "label": "Greater Than (>)",
          "value": "greaterThan"
        },
        {
          "id": "op-lt",
          "label": "Less Than (<)",
          "value": "lessThan"
        },
        {
          "id": "op-gte",
          "label": "Greater or Equal (>=)",
          "value": "greaterThanOrEqual"
        },
        {
          "id": "op-lte",
          "label": "Less or Equal (<=)",
          "value": "lessThanOrEqual"
        },
        {
          "id": "op-contains",
          "label": "Contains",
          "value": "contains"
        },
        {
          "id": "op-startsWith",
          "label": "Starts With",
          "value": "startsWith"
        },
        {
          "id": "op-endsWith",
          "label": "Ends With",
          "value": "endsWith"
        },
        {
          "id": "op-in",
          "label": "In Array",
          "value": "in"
        },
        {
          "id": "op-exists",
          "label": "Field Exists",
          "value": "exists"
        },
        {
          "id": "op-empty",
          "label": "Is Empty",
          "value": "empty"
        }
      ],
      "displayOptions": {
        "show": {
          "operation": [
            "filter",
            "find"
          ]
        }
      }
    },
    {
      "name": "filterValue",
      "displayName": "Value",
      "type": "string",
      "ui": {
        "component": "code"
      },
      "description": "Value to compare against",
      "displayOptions": {
        "show": {
          "operation": [
            "filter",
            "find"
          ]
        }
      }
    },
    {
      "name": "sortField",
      "displayName": "Sort By Field",
      "type": "string",
      "placeholder": "price, createdAt, user.name",
      "description": "Field to sort by (supports nested paths)",
      "displayOptions": {
        "show": {
          "operation": [
            "sort"
          ]
        }
      }
    },
    {
      "name": "sortDirection",
      "displayName": "Sort Direction",
      "type": "options",
      "default": "asc",
      "options": [
        {
          "id": "dir-asc",
          "label": "Ascending (A→Z, 0→9)",
          "value": "asc"
        },
        {
          "id": "dir-desc",
          "label": "Descending (Z→A, 9→0)",
          "value": "desc"
        }
      ],
      "displayOptions": {
        "show": {
          "operation": [
            "sort"
          ]
        }
      }
    },
    {
      "name": "uniqueField",
      "displayName": "Unique By Field",
      "type": "string",
      "placeholder": "id, email (leave empty for full object comparison)",
      "description": "Field to determine uniqueness",
      "displayOptions": {
        "show": {
          "operation": [
            "unique"
          ]
        }
      }
    },
    {
      "name": "limitCount",
      "displayName": "Limit",
      "type": "number",
      "default": 10,
      "description": "Maximum number of items to return",
      "displayOptions": {
        "show": {
          "operation": [
            "limit"
          ]
        }
      }
    },
    {
      "name": "limitOffset",
      "displayName": "Offset",
      "type": "number",
      "default": 0,
      "description": "Number of items to skip",
      "displayOptions": {
        "show": {
          "operation": [
            "limit"
          ]
        }
      }
    }
  ],
  "executionCode": "const operation = node.properties.operation.value;\nlet inputArray = node.properties.inputArray.value;\nconst filterField = node.properties.filterField?.value;\nconst filterOperator = node.properties.filterOperator?.value || 'equals';\nlet filterValue = node.properties.filterValue?.value;\nconst sortField = node.properties.sortField?.value;\nconst sortDirection = node.properties.sortDirection?.value || 'asc';\nconst uniqueField = node.properties.uniqueField?.value;\nconst limitCount = node.properties.limitCount?.value || 10;\nconst limitOffset = node.properties.limitOffset?.value || 0;\n\n// Resolve template variables\nconst resolveValue = (val) => {\n  if (typeof val === 'string') {\n    if (val === '{{data}}') return data;\n    if (val.includes('{{data.')) {\n      const match = val.match(/\\{\\{data\\.([^}]+)\\}\\}/);\n      if (match) {\n        const path = match[1].split('.');\n        let result = data;\n        for (const part of path) {\n          result = result?.[part];\n        }\n        return result;\n      }\n    }\n  }\n  return val;\n};\n\ninputArray = resolveValue(inputArray);\nfilterValue = resolveValue(filterValue);\n\n// Ensure it's an array\nif (!Array.isArray(inputArray)) {\n  return {\n    error: 'Input is not an array',\n    receivedType: typeof inputArray\n  };\n}\n\n// Helper to get nested value\nconst getNestedValue = (obj, path) => {\n  if (!path) return obj;\n  const keys = path.split('.');\n  let result = obj;\n  for (const key of keys) {\n    if (result === null || result === undefined) return undefined;\n    result = result[key];\n  }\n  return result;\n};\n\n// Helper to compare values\nconst compareValues = (a, b, operator) => {\n  switch (operator) {\n    case 'equals':\n      return a == b;\n    case 'notEquals':\n      return a != b;\n    case 'greaterThan':\n      return a > b;\n    case 'lessThan':\n      return a < b;\n    case 'greaterThanOrEqual':\n      return a >= b;\n    case 'lessThanOrEqual':\n      return a <= b;\n    case 'contains':\n      return String(a).includes(String(b));\n    case 'startsWith':\n      return String(a).startsWith(String(b));\n    case 'endsWith':\n      return String(a).endsWith(String(b));\n    case 'in':\n      return Array.isArray(b) ? b.includes(a) : false;\n    case 'exists':\n      return a !== undefined && a !== null;\n    case 'empty':\n      return !a || (Array.isArray(a) && a.length === 0) || (typeof a === 'string' && a.trim() === '');\n    default:\n      return false;\n  }\n};\n\nhelpers.log('Starting Filter & Sort node');\nhelpers.log(`Operation: ${operation}`);\nhelpers.log(`Input array length: ${inputArray.length}`);\n\ntry {\n  let result;\n  \n  switch (operation) {\n    case 'filter': {\n      helpers.log(`Filtering by field: ${filterField}`);\n      helpers.log(`Operator: ${filterOperator}`);\n      helpers.log(`Filter value: ${JSON.stringify(filterValue)}`);\n      \n      result = inputArray.filter(item => {\n        const fieldValue = getNestedValue(item, filterField);\n        return compareValues(fieldValue, filterValue, filterOperator);\n      });\n      \n      helpers.log(`Filtered ${inputArray.length} items down to ${result.length} items`);\n      \n      return {\n        success: true,\n        operation: 'filter',\n        result,\n        originalCount: inputArray.length,\n        filteredCount: result.length,\n        filterField,\n        filterOperator,\n        filterValue\n      };\n    }\n    \n    case 'find': {\n      helpers.log(`Finding first item where ${filterField} ${filterOperator} ${JSON.stringify(filterValue)}`);\n      \n      result = inputArray.find(item => {\n        const fieldValue = getNestedValue(item, filterField);\n        return compareValues(fieldValue, filterValue, filterOperator);\n      });\n      \n      if (result) {\n        helpers.log('Found matching item');\n      } else {\n        helpers.log('No matching item found');\n      }\n      \n      return {\n        success: true,\n        operation: 'find',\n        result: result || null,\n        found: !!result,\n        filterField,\n        filterOperator,\n        filterValue\n      };\n    }\n    \n    case 'sort': {\n      helpers.log(`Sorting by field: ${sortField}`);\n      helpers.log(`Sort direction: ${sortDirection}`);\n      \n      result = [...inputArray].sort((a, b) => {\n        const aVal = getNestedValue(a, sortField);\n        const bVal = getNestedValue(b, sortField);\n        \n        // Handle null/undefined\n        if (aVal === null || aVal === undefined) return 1;\n        if (bVal === null || bVal === undefined) return -1;\n        \n        // Compare\n        let comparison = 0;\n        if (aVal > bVal) comparison = 1;\n        if (aVal < bVal) comparison = -1;\n        \n        return sortDirection === 'desc' ? -comparison : comparison;\n      });\n      \n      helpers.log(`Sorted ${result.length} items`);\n      \n      return {\n        success: true,\n        operation: 'sort',\n        result,\n        count: result.length,\n        sortField,\n        sortDirection\n      };\n    }\n    \n    case 'unique': {\n      if (uniqueField) {\n        helpers.log(`Removing duplicates by field: ${uniqueField}`);\n        // Remove duplicates by field\n        const seen = new Set();\n        result = inputArray.filter(item => {\n          const value = getNestedValue(item, uniqueField);\n          const key = JSON.stringify(value);\n          if (seen.has(key)) return false;\n          seen.add(key);\n          return true;\n        });\n      } else {\n        helpers.log('Removing duplicates by full object comparison');\n        // Remove duplicates by full object\n        const seen = new Set();\n        result = inputArray.filter(item => {\n          const key = JSON.stringify(item);\n          if (seen.has(key)) return false;\n          seen.add(key);\n          return true;\n        });\n      }\n      \n      helpers.log(`Removed ${inputArray.length - result.length} duplicates (${result.length} unique items remaining)`);\n      \n      return {\n        success: true,\n        operation: 'unique',\n        result,\n        originalCount: inputArray.length,\n        uniqueCount: result.length,\n        duplicatesRemoved: inputArray.length - result.length,\n        uniqueField\n      };\n    }\n    \n    case 'limit': {\n      helpers.log(`Limiting results: offset=${limitOffset}, count=${limitCount}`);\n      result = inputArray.slice(limitOffset, limitOffset + limitCount);\n      helpers.log(`Returned ${result.length} items from ${inputArray.length} total`);\n      \n      return {\n        success: true,\n        operation: 'limit',\n        result,\n        originalCount: inputArray.length,\n        returnedCount: result.length,\n        limit: limitCount,\n        offset: limitOffset\n      };\n    }\n    \n    default:\n      return { error: `Unknown operation: ${operation}` };\n  }\n} catch (error) {\n  helpers.error('Filter/Sort operation failed:', error);\n  return {\n    error: error.message,\n    operation\n  };\n}\n",
  "meta": {
    "author": "Nodify System",
    "createdAt": "2025-10-15"
  }
}